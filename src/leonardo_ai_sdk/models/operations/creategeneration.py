"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import httpx
from leonardo_ai_sdk.models.shared import (
    canvasrequesttype as shared_canvasrequesttype,
    controlnet_input as shared_controlnet_input,
    controlnet_type as shared_controlnet_type,
    element_input as shared_element_input,
    sd_generation_schedulers as shared_sd_generation_schedulers,
    sd_generation_style as shared_sd_generation_style,
    sd_versions as shared_sd_versions,
)
from leonardo_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import List, Optional, TypedDict
from typing_extensions import Annotated, NotRequired


class TransparencyType(str, Enum):
    r"""Which type of transparency this image should use"""

    DISABLED = "disabled"
    FOREGROUND_ONLY = "foreground_only"


class CreateGenerationRequestBodyTypedDict(TypedDict):
    r"""Query parameters to be provided in the request body as a JSON object"""

    alchemy: NotRequired[Nullable[bool]]
    r"""Enable to use Alchemy. Note: The appropriate Alchemy version is selected for the specified model. For example, XL models will use Alchemy V2."""
    canvas_init_id: NotRequired[Nullable[str]]
    r"""The ID of an initial image to use in Canvas Editor request."""
    canvas_mask_id: NotRequired[Nullable[str]]
    r"""The ID of a mask image to use in Canvas Editor request."""
    canvas_request: NotRequired[Nullable[bool]]
    r"""Whether the generation is for the Canvas Editor feature."""
    canvas_request_type: NotRequired[
        Nullable[shared_canvasrequesttype.CanvasRequestType]
    ]
    r"""The type of request for the Canvas Editor."""
    contrast_ratio: NotRequired[Nullable[float]]
    r"""Contrast Ratio to use with Alchemy. Must be a float between 0 and 1 inclusive."""
    control_net: NotRequired[Nullable[bool]]
    r"""This parameter will be deprecated in September 2024. Please use the controlnets array instead."""
    control_net_type: NotRequired[shared_controlnet_type.ControlnetType]
    r"""This parameter will be deprecated in September 2024. Please use the controlnets array instead."""
    controlnets: NotRequired[
        Nullable[List[shared_controlnet_input.ControlnetInputTypedDict]]
    ]
    elements: NotRequired[Nullable[List[shared_element_input.ElementInputTypedDict]]]
    expanded_domain: NotRequired[Nullable[bool]]
    r"""Enable to use the Expanded Domain feature of Alchemy."""
    fantasy_avatar: NotRequired[Nullable[bool]]
    r"""Enable to use the Fantasy Avatar feature."""
    guidance_scale: NotRequired[Nullable[int]]
    r"""How strongly the generation should reflect the prompt. 7 is recommended. Must be between 1 and 20."""
    height: NotRequired[Nullable[int]]
    r"""The input height of the images. Must be between 32 and 1024 and be a multiple of 8. Note: Input resolution is not always the same as output resolution due to upscaling from other features."""
    high_contrast: NotRequired[Nullable[bool]]
    r"""Enable to use the High Contrast feature of Prompt Magic. Note: Controls RAW mode. Set to false to enable RAW mode."""
    high_resolution: NotRequired[Nullable[bool]]
    r"""Enable to use the High Resolution feature of Prompt Magic."""
    image_prompt_weight: NotRequired[Nullable[float]]
    image_prompts: NotRequired[Nullable[List[str]]]
    init_generation_image_id: NotRequired[Nullable[str]]
    r"""The ID of an existing image to use in image2image."""
    init_image_id: NotRequired[Nullable[str]]
    r"""The ID of an Init Image to use in image2image."""
    init_strength: NotRequired[Nullable[float]]
    r"""How strongly the generated images should reflect the original image in image2image. Must be a float between 0.1 and 0.9."""
    model_id: NotRequired[Nullable[str]]
    r"""The model ID used for image generation. If not provided, uses sd_version to determine the version of Stable Diffusion to use. In-app, model IDs are under the Finetune Models menu. Click on the platform model or your custom model, then click View More. For platform models, you can also use the List Platform Models API."""
    negative_prompt: NotRequired[Nullable[str]]
    r"""The negative prompt used for the image generation"""
    num_images: NotRequired[Nullable[int]]
    r"""The number of images to generate. Must be between 1 and 8. If either width or height is over 768, must be between 1 and 4."""
    num_inference_steps: NotRequired[Nullable[int]]
    r"""The Step Count to use for the generation. Must be between 10 and 60. Default is 15."""
    photo_real: NotRequired[Nullable[bool]]
    r"""Enable the photoReal feature. Requires enabling alchemy and unspecifying modelId (for photoRealVersion V1)."""
    photo_real_strength: NotRequired[Nullable[float]]
    r"""Depth of field of photoReal. Must be 0.55 for low, 0.5 for medium, or 0.45 for high. Defaults to 0.55 if not specified."""
    photo_real_version: NotRequired[Nullable[str]]
    r"""The version of photoReal to use. Must be v1 or v2."""
    preset_style: NotRequired[Nullable[shared_sd_generation_style.SdGenerationStyle]]
    r"""The style to generate images with. When photoReal is enabled, refer to the Guide section for a full list. When alchemy is disabled, use LEONARDO or NONE. When alchemy is enabled, use ANIME, CREATIVE, DYNAMIC, ENVIRONMENT, GENERAL, ILLUSTRATION, PHOTOGRAPHY, RAYTRACED, RENDER_3D, SKETCH_BW, SKETCH_COLOR, or NONE."""
    prompt: NotRequired[str]
    r"""The prompt used to generate images"""
    prompt_magic: NotRequired[Nullable[bool]]
    r"""Enable to use Prompt Magic."""
    prompt_magic_strength: NotRequired[Nullable[float]]
    r"""Strength of prompt magic. Must be a float between 0.1 and 1.0"""
    prompt_magic_version: NotRequired[Nullable[str]]
    r"""Prompt magic version v2 or v3, for use when promptMagic: true"""
    public: NotRequired[Nullable[bool]]
    r"""Whether the generated images should show in the community feed."""
    scheduler: NotRequired[shared_sd_generation_schedulers.SdGenerationSchedulers]
    r"""The scheduler to generate images with. Defaults to EULER_DISCRETE if not specified."""
    sd_version: NotRequired[shared_sd_versions.SdVersions]
    r"""The base version of stable diffusion to use if not using a custom model. v1_5 is 1.5, v2 is 2.1, if not specified it will default to v1_5. Also includes SDXL and SDXL Lightning models"""
    seed: NotRequired[Nullable[int]]
    tiling: NotRequired[Nullable[bool]]
    r"""Whether the generated images should tile on all axis."""
    transparency: NotRequired[Nullable[TransparencyType]]
    r"""Which type of transparency this image should use"""
    unzoom: NotRequired[Nullable[bool]]
    r"""Whether the generated images should be unzoomed (requires unzoomAmount and init_image_id to be set)."""
    unzoom_amount: NotRequired[Nullable[float]]
    r"""How much the image should be unzoomed (requires an init_image_id and unzoom to be set to true)."""
    upscale_ratio: NotRequired[Nullable[float]]
    r"""How much the image should be upscaled. (Enterprise Only)"""
    weighting: NotRequired[Nullable[float]]
    r"""This parameter will be deprecated in September 2024. Please use the controlnets array instead."""
    width: NotRequired[Nullable[int]]
    r"""The input width of the images. Must be between 32 and 1024 and be a multiple of 8. Note: Input resolution is not always the same as output resolution due to upscaling from other features."""


class CreateGenerationRequestBody(BaseModel):
    r"""Query parameters to be provided in the request body as a JSON object"""

    alchemy: OptionalNullable[bool] = True
    r"""Enable to use Alchemy. Note: The appropriate Alchemy version is selected for the specified model. For example, XL models will use Alchemy V2."""

    canvas_init_id: Annotated[
        OptionalNullable[str], pydantic.Field(alias="canvasInitId")
    ] = UNSET
    r"""The ID of an initial image to use in Canvas Editor request."""

    canvas_mask_id: Annotated[
        OptionalNullable[str], pydantic.Field(alias="canvasMaskId")
    ] = UNSET
    r"""The ID of a mask image to use in Canvas Editor request."""

    canvas_request: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="canvasRequest")
    ] = UNSET
    r"""Whether the generation is for the Canvas Editor feature."""

    canvas_request_type: Annotated[
        OptionalNullable[shared_canvasrequesttype.CanvasRequestType],
        pydantic.Field(alias="canvasRequestType"),
    ] = UNSET
    r"""The type of request for the Canvas Editor."""

    contrast_ratio: Annotated[
        OptionalNullable[float], pydantic.Field(alias="contrastRatio")
    ] = UNSET
    r"""Contrast Ratio to use with Alchemy. Must be a float between 0 and 1 inclusive."""

    control_net: Annotated[
        OptionalNullable[bool],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible.",
            alias="controlNet",
        ),
    ] = UNSET
    r"""This parameter will be deprecated in September 2024. Please use the controlnets array instead."""

    control_net_type: Annotated[
        Optional[shared_controlnet_type.ControlnetType],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible.",
            alias="controlNetType",
        ),
    ] = None
    r"""This parameter will be deprecated in September 2024. Please use the controlnets array instead."""

    controlnets: OptionalNullable[List[shared_controlnet_input.ControlnetInput]] = UNSET

    elements: OptionalNullable[List[shared_element_input.ElementInput]] = UNSET

    expanded_domain: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="expandedDomain")
    ] = UNSET
    r"""Enable to use the Expanded Domain feature of Alchemy."""

    fantasy_avatar: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="fantasyAvatar")
    ] = UNSET
    r"""Enable to use the Fantasy Avatar feature."""

    guidance_scale: OptionalNullable[int] = UNSET
    r"""How strongly the generation should reflect the prompt. 7 is recommended. Must be between 1 and 20."""

    height: OptionalNullable[int] = 768
    r"""The input height of the images. Must be between 32 and 1024 and be a multiple of 8. Note: Input resolution is not always the same as output resolution due to upscaling from other features."""

    high_contrast: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="highContrast")
    ] = UNSET
    r"""Enable to use the High Contrast feature of Prompt Magic. Note: Controls RAW mode. Set to false to enable RAW mode."""

    high_resolution: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="highResolution")
    ] = UNSET
    r"""Enable to use the High Resolution feature of Prompt Magic."""

    image_prompt_weight: Annotated[
        OptionalNullable[float], pydantic.Field(alias="imagePromptWeight")
    ] = UNSET

    image_prompts: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="imagePrompts")
    ] = UNSET

    init_generation_image_id: OptionalNullable[str] = UNSET
    r"""The ID of an existing image to use in image2image."""

    init_image_id: OptionalNullable[str] = UNSET
    r"""The ID of an Init Image to use in image2image."""

    init_strength: OptionalNullable[float] = UNSET
    r"""How strongly the generated images should reflect the original image in image2image. Must be a float between 0.1 and 0.9."""

    model_id: Annotated[OptionalNullable[str], pydantic.Field(alias="modelId")] = (
        "b24e16ff-06e3-43eb-8d33-4416c2d75876"
    )
    r"""The model ID used for image generation. If not provided, uses sd_version to determine the version of Stable Diffusion to use. In-app, model IDs are under the Finetune Models menu. Click on the platform model or your custom model, then click View More. For platform models, you can also use the List Platform Models API."""

    negative_prompt: OptionalNullable[str] = UNSET
    r"""The negative prompt used for the image generation"""

    num_images: OptionalNullable[int] = 4
    r"""The number of images to generate. Must be between 1 and 8. If either width or height is over 768, must be between 1 and 4."""

    num_inference_steps: OptionalNullable[int] = UNSET
    r"""The Step Count to use for the generation. Must be between 10 and 60. Default is 15."""

    photo_real: Annotated[OptionalNullable[bool], pydantic.Field(alias="photoReal")] = (
        UNSET
    )
    r"""Enable the photoReal feature. Requires enabling alchemy and unspecifying modelId (for photoRealVersion V1)."""

    photo_real_strength: Annotated[
        OptionalNullable[float], pydantic.Field(alias="photoRealStrength")
    ] = UNSET
    r"""Depth of field of photoReal. Must be 0.55 for low, 0.5 for medium, or 0.45 for high. Defaults to 0.55 if not specified."""

    photo_real_version: Annotated[
        OptionalNullable[str], pydantic.Field(alias="photoRealVersion")
    ] = UNSET
    r"""The version of photoReal to use. Must be v1 or v2."""

    preset_style: Annotated[
        OptionalNullable[shared_sd_generation_style.SdGenerationStyle],
        pydantic.Field(alias="presetStyle"),
    ] = shared_sd_generation_style.SdGenerationStyle.DYNAMIC
    r"""The style to generate images with. When photoReal is enabled, refer to the Guide section for a full list. When alchemy is disabled, use LEONARDO or NONE. When alchemy is enabled, use ANIME, CREATIVE, DYNAMIC, ENVIRONMENT, GENERAL, ILLUSTRATION, PHOTOGRAPHY, RAYTRACED, RENDER_3D, SKETCH_BW, SKETCH_COLOR, or NONE."""

    prompt: Optional[str] = "A majestic cat in the snow"
    r"""The prompt used to generate images"""

    prompt_magic: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="promptMagic")
    ] = UNSET
    r"""Enable to use Prompt Magic."""

    prompt_magic_strength: Annotated[
        OptionalNullable[float], pydantic.Field(alias="promptMagicStrength")
    ] = UNSET
    r"""Strength of prompt magic. Must be a float between 0.1 and 1.0"""

    prompt_magic_version: Annotated[
        OptionalNullable[str], pydantic.Field(alias="promptMagicVersion")
    ] = UNSET
    r"""Prompt magic version v2 or v3, for use when promptMagic: true"""

    public: OptionalNullable[bool] = UNSET
    r"""Whether the generated images should show in the community feed."""

    scheduler: Optional[shared_sd_generation_schedulers.SdGenerationSchedulers] = None
    r"""The scheduler to generate images with. Defaults to EULER_DISCRETE if not specified."""

    sd_version: Optional[shared_sd_versions.SdVersions] = None
    r"""The base version of stable diffusion to use if not using a custom model. v1_5 is 1.5, v2 is 2.1, if not specified it will default to v1_5. Also includes SDXL and SDXL Lightning models"""

    seed: OptionalNullable[int] = UNSET

    tiling: OptionalNullable[bool] = UNSET
    r"""Whether the generated images should tile on all axis."""

    transparency: OptionalNullable[TransparencyType] = UNSET
    r"""Which type of transparency this image should use"""

    unzoom: OptionalNullable[bool] = UNSET
    r"""Whether the generated images should be unzoomed (requires unzoomAmount and init_image_id to be set)."""

    unzoom_amount: Annotated[
        OptionalNullable[float], pydantic.Field(alias="unzoomAmount")
    ] = UNSET
    r"""How much the image should be unzoomed (requires an init_image_id and unzoom to be set to true)."""

    upscale_ratio: Annotated[
        OptionalNullable[float], pydantic.Field(alias="upscaleRatio")
    ] = UNSET
    r"""How much the image should be upscaled. (Enterprise Only)"""

    weighting: Annotated[
        OptionalNullable[float],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = UNSET
    r"""This parameter will be deprecated in September 2024. Please use the controlnets array instead."""

    width: OptionalNullable[int] = 1024
    r"""The input width of the images. Must be between 32 and 1024 and be a multiple of 8. Note: Input resolution is not always the same as output resolution due to upscaling from other features."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "alchemy",
            "canvasInitId",
            "canvasMaskId",
            "canvasRequest",
            "canvasRequestType",
            "contrastRatio",
            "controlNet",
            "controlNetType",
            "controlnets",
            "elements",
            "expandedDomain",
            "fantasyAvatar",
            "guidance_scale",
            "height",
            "highContrast",
            "highResolution",
            "imagePromptWeight",
            "imagePrompts",
            "init_generation_image_id",
            "init_image_id",
            "init_strength",
            "modelId",
            "negative_prompt",
            "num_images",
            "num_inference_steps",
            "photoReal",
            "photoRealStrength",
            "photoRealVersion",
            "presetStyle",
            "prompt",
            "promptMagic",
            "promptMagicStrength",
            "promptMagicVersion",
            "public",
            "scheduler",
            "sd_version",
            "seed",
            "tiling",
            "transparency",
            "unzoom",
            "unzoomAmount",
            "upscaleRatio",
            "weighting",
            "width",
        ]
        nullable_fields = [
            "alchemy",
            "canvasInitId",
            "canvasMaskId",
            "canvasRequest",
            "canvasRequestType",
            "contrastRatio",
            "controlNet",
            "controlnets",
            "elements",
            "expandedDomain",
            "fantasyAvatar",
            "guidance_scale",
            "height",
            "highContrast",
            "highResolution",
            "imagePromptWeight",
            "imagePrompts",
            "init_generation_image_id",
            "init_image_id",
            "init_strength",
            "modelId",
            "negative_prompt",
            "num_images",
            "num_inference_steps",
            "photoReal",
            "photoRealStrength",
            "photoRealVersion",
            "presetStyle",
            "promptMagic",
            "promptMagicStrength",
            "promptMagicVersion",
            "public",
            "seed",
            "tiling",
            "transparency",
            "unzoom",
            "unzoomAmount",
            "upscaleRatio",
            "weighting",
            "width",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class SDGenerationOutputTypedDict(TypedDict):
    api_credit_cost: NotRequired[Nullable[int]]
    r"""API Credits Cost for Image Generation. Available for Production API Users."""
    generation_id: NotRequired[str]


class SDGenerationOutput(BaseModel):
    api_credit_cost: Annotated[
        OptionalNullable[int], pydantic.Field(alias="apiCreditCost")
    ] = UNSET
    r"""API Credits Cost for Image Generation. Available for Production API Users."""

    generation_id: Annotated[Optional[str], pydantic.Field(alias="generationId")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["apiCreditCost", "generationId"]
        nullable_fields = ["apiCreditCost"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateGenerationResponseBodyTypedDict(TypedDict):
    r"""Responses for POST /generations"""

    sd_generation_job: NotRequired[Nullable[SDGenerationOutputTypedDict]]


class CreateGenerationResponseBody(BaseModel):
    r"""Responses for POST /generations"""

    sd_generation_job: Annotated[
        OptionalNullable[SDGenerationOutput], pydantic.Field(alias="sdGenerationJob")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["sdGenerationJob"]
        nullable_fields = ["sdGenerationJob"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateGenerationResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[CreateGenerationResponseBodyTypedDict]
    r"""Responses for POST /generations"""


class CreateGenerationResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[CreateGenerationResponseBody] = None
    r"""Responses for POST /generations"""
